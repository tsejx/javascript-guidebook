(window.webpackJsonp=window.webpackJsonp||[]).push([[98],{561:function(t,r,e){"use strict";e.r(r);var _=e(0),v=Object(_.a)({},(function(){var t=this,r=t.$createElement,e=t._self._c||r;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#绘制"}},[t._v("#")]),t._v(" 绘制")]),t._v(" "),e("p",[t._v("在绘制阶段，系统会遍历渲染树，并调用渲染器的 "),e("code",[t._v("paint")]),t._v(" 方法，将渲染器的内容绘制成位图。")]),t._v(" "),e("p",[t._v("绘制工作是使用用户界面基础组件完成的。你所看见的一切都会触发 "),e("code",[t._v("paint")]),t._v("。包括拖动滚动条，鼠标选择中文字等这些完全不改变样式，只改变显示结果的动作都会触发 "),e("code",[t._v("paint")]),t._v("。")]),t._v(" "),e("p",[e("code",[t._v("paint")]),t._v(" 的工作就是把文档中用户可见的那一部分展现给用户。"),e("code",[t._v("paint")]),t._v(" 是把 "),e("code",[t._v("layout")]),t._v(" 和样式计算的结果直接在浏览器视窗上绘制出来，它并不实现具体的元素计算，只是 "),e("code",[t._v("layout")]),t._v(" 后面的那一步。")]),t._v(" "),e("h2",{attrs:{id:"全局绘制和增量绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#全局绘制和增量绘制"}},[t._v("#")]),t._v(" 全局绘制和增量绘制")]),t._v(" "),e("p",[t._v("和布局一样，绘制也分为全局和增量两种。")]),t._v(" "),e("p",[t._v("在增量绘制中，部分渲染器发生了更改，但是不会影响整个树。更改后的渲染器将其在屏幕上对应的矩形区域设为无效，这导致 OS 将其视为一块 dirty 区域，并生成 "),e("code",[t._v("paint")]),t._v(" 事件。OS 会很巧妙地将多个区域合并成一个。在 Chrome 浏览器中，情况要更复杂一些，因为 Chrome 浏览器的渲染器不在主进程上。Chrome 浏览器会在某种程度上模拟 OS 的行为。展示层会侦听这些事件，并将消息委托给呈现根节点。然后遍历渲染树，直到找到相关的呈现器，该呈现器会重新绘制自己（通常也包括其子代）。")]),t._v(" "),e("h2",{attrs:{id:"绘制顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#绘制顺序"}},[t._v("#")]),t._v(" 绘制顺序")]),t._v(" "),e("p",[e("a",{attrs:{href:"http://www.w3.org/TR/CSS21/zindex.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS2 规范"),e("OutboundLink")],1),t._v(" 定义了绘制流程的顺序。绘制的顺序其实就是元素进入 "),e("a",{attrs:{href:"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#stackingcontext",target:"_blank",rel:"noopener noreferrer"}},[t._v("堆栈样式上下文"),e("OutboundLink")],1),t._v(" 的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：")]),t._v(" "),e("ol",[e("li",[t._v("背景颜色（background-color）")]),t._v(" "),e("li",[t._v("背景图片（background-image）")]),t._v(" "),e("li",[t._v("边框（border）")]),t._v(" "),e("li",[t._v("子代")]),t._v(" "),e("li",[t._v("轮廓（outline）")])]),t._v(" "),e("p",[t._v("在样式发生变化时，浏览器会尽可能做出最小的响应。因此，元素的颜色改变后，只会对该元素进行重绘。元素的位置改变后，只会对该元素及其子元素（可能还有同级元素）进行布局和重绘。添加 DOM 节点后，会对该节点进行布局和重绘。一些重大变化（例如增大 "),e("code",[t._v("<html>")]),t._v(" 元素的字体）会导致缓存无效，使得整个渲染树都会进行重新布局和绘制。")])])}),[],!1,null,null,null);r.default=v.exports}}]);