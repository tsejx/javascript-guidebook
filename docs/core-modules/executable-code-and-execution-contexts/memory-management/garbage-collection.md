---
nav:
  title: 核心模块
  order: 3
group:
  title: 内存管理
  order: 4
title: 垃圾回收
order: 3
---

# 垃圾回收

> 由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。——《JavaScript 权威指南》

在 C 和 C++ 之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写 JavaScript 的过程中，内存的分配以及内存的回收完全实现了自动管理。

JavaScript 通过 **自动垃圾收集机制** 实现内存的管理。垃圾回收机制通过垃圾收集器每隔固定的时间段（周期性）找出那些不再需要继续使用的变量，执行一次释放其占用的内存操作。

> 什么是不再需要继续使用的值？

不再需要继续使用的变量也就是生命周期结束的变量。

* **局部变量：**在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了（除了闭包），因此垃圾收集器很容易做出判断并回收。
* **全局变量：**但是全局变量的生命周期直到浏览器卸载页面才会结束，也就是**全局变量不会被当成垃圾回收**。所以声明一个全局变量的时候，我们一定要慎重的考虑，在使用完这个变量的对象之后，我们是否还在需要这个对象，如果不需要的话，我们应该手动的将这个变量置为空（`null`），这样在下一次垃圾回收的时候，就能去释放这个变量上一次指向的对象（请注意变量与对象的区别）。

## 原理

JavaScript 有两种策略实现垃圾回收机制：[标记清除法](#标记清除法) 和 [引用计数法](引用计数法)。

### 标记清除法

**标记清除法：** 当程序执行流入到一个函数中时，会创建该函数的执行上下文，执行上下文中的变量都会被标记为 **进入环境**，从逻辑上讲，永远不能释放 **进入执行环境** 变量所占用的内存。因为只要执行流进入相应的执行上下文，就可能会用到这些变量。

标记清除的工作流程：

* 垃圾收集器在运行的时候会给存储在内存的中的 **所有变量都加上标记**
* 去掉 **执行上下文中的变量** 以及 **被环境中的变量引用的变量** 的标记
* 那些 **还存在标记的变量将被视为准备删除的变量**
* 最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间

手动释放内存：

```js
let a = 1;

a = null;
```

`a = null` 其实仅仅只是做了一个释放引用的操作，让变量 `a` 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。

### 引用计数法

**引用计数法：** 跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 1，如果这个值再被赋值给另一个变量，则引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 1。当这个引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 0 的值所占的内存。

这种垃圾收集方式存在一个比较大的问题就是循环引用，就是说对象 `a` 包含一个指向 `b` 的指针，对象 `b` 也包含一个指向 `a` 的引用。 这就可能造成大量内存得不到回收（内存泄漏），因为它们的引用次数永远不可能是 0 。

```js
function problem(){
  var a = new Object()
  var b = new Object()
  a.ref = b
  b.ref = a
}
```

## 内存泄漏

内存泄漏即由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。

- 即使 1Byte 的内存，也叫内存泄漏，并不一定是导致浏览器奔溃、卡顿才能叫内存泄漏
- 一般是堆区内存泄漏，栈区不会泄漏。基本数据类型的值保存在栈中，引用数据类型保存在堆中。所以对象、数组等才会发生内存泄漏。

### 全局变量

全局变量不会被当成垃圾回收，我们在编码中应该尽量避免声明全局变量。

```js
function foo(){
  // 默认绑定 => window.bar = 10
  this.bar = 10;
  // 没有显式声明变量 实际是全局变量 => window.baz = 20
  baz = 20;
}

foo();
```

当我们使用 [默认绑定](../execution/this.md#默认绑定)，`this` 会指向全局对象。

🔧 **解决方法：** 在函数内使用严格模式或手动释放全局变量的内存。

### 定时器

当不需要 `setInterval` 或者 `setTimeout` 时，定时器没有被清除，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。

```js
const someResource = getData();

// node、someResource 存储了大量数据 无法回收
const timerId = setInterval(function() {
  const node = document.getElementById('Node');

  if(node) {
    // 定时器也没有清除
    node.innerHTML = JSON.stringify(someResource);
  }
}, 1000);

clearInterval(timerId)
```

🔧 **解决方法**：在定时器完成工作的时候，手动清除定时器。

### 闭包

闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏。

```js
function bindEvent(){
  const o = document.createElement('foo');
  const unused = function(){
    // 闭包内引用变量 o 将不会释放
    console.log(o)
  }
}
```

🔧 **解决方法**：手动解除引用 `o = null`

---

**参考资料：**

* [📝 内存基本知识](<https://segmentfault.com/a/1190000006104910>)
* [📝 JavaScript 内存机制](<https://juejin.im/post/5b10ba336fb9a01e66164346>)
* [📝 An interesting kind of JavaScript memory leak](<https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156>)